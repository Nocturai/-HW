# 51115119

作業一 - ackermann函數

## 解題說明

本題要求實作數學上著名的 Ackermann 函數，並透過遞迴方式計算其結果。

### 解題策略

- 直接對應條件分支
使用 if 判斷式依序處理三種情況，讓程式邏輯與數學定義一致。
- 避免額外資料結構
由於遞迴本身已隱含堆疊結構，不需使用陣列或容器模擬。
- 測試小範圍輸入
Ackermann 函數成長極快，輸入稍大就可能導致 Stack Overflow，因此測試時僅使用小於等於 m = 3、n \leq 10 的範圍。
- 保留使用者輸入
讓使用者輸入 m 與 n，方便測試不同組合並觀察結果。


## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>

using namespace std;

int a(int m, int n) {
    if (m == 0) return n + 1;
    if (n == 0) return a(m - 1, 1);
    return a(m - 1, a(m, n - 1));
}

int main() {
    int m,n;
    
    cout << "input m n" << endl;
    cin >> m >> n;
    cout << m << "," << n << "," << a(m,n) << endl;

    system("pause");
    return 0;
}
```

## 效能分析

1. 時間複雜度 - 無法以簡單的漸進符號表示：Ackermann 函數的遞迴深度與計算次數隨著 m 和 n 增加而爆炸性成長。
2. 空間複雜度 - 與遞迴深度成正比：每次遞迴呼叫都會佔用一層堆疊空間, 容易導致 Stack Overflow。


## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 m | 輸入參數 n | 預期輸出 | 實際輸出 |
|----------|--------------|---------|----------|---------|
| 測試一   | $m = 0$      | $n = 0$  | 1        |1       |
| 測試二   | $m = 1$      | $n = 2$ | 4        |4         |
| 測試三   | $m = 2$      |$n = 2$ | 7        | 7         |
| 測試四   | $m = 3$      | $n = 4$  |29       |29        |

### 編譯與執行指令

```shell
$ g++ -std=c++17 -o ackermann ackermann.cpp
$ ./ackermann

```

### 結論

本作業成功實作了 Ackermann 函數的遞迴版本，並透過簡潔的條件分支對應數學定義。
透過使用者輸入參數 m 與 n，程式能正確計算出對應的結果，
並展示遞迴函數在處理高度巢狀呼叫時的威力與限制。


## 申論及開發報告

選擇遞迴的理由
- 符合數學定義：Ackermann 函數本身就是遞迴定義，使用遞迴能直接對應公式。
- 程式簡潔：遞迴能清楚表達三種條件分支，避免複雜的迴圈與堆疊模擬。
```cpp
   int a(int m, int n) {
    if (m == 0) return n + 1;
    if (n == 0) return a(m - 1, 1);
    return a(m - 1, a(m, n - 1));
}
```
